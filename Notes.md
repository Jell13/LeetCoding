-- DUPLICATE INTEGERS --

use a dictionary as they are very fast in terms of finding whether a key exist or not, find whether or not the number already existed inside of the dictionary, if no then add it in, if yes it means it does exist and we've seen the number before which we are able to conclude that they are a duplicate.

-- IS ANAGRAM --

use a dictionary again, for this one we make sure they are the same length first because its looking for anagram if they don't have the same length they are not an anagram. The next step is to loop through the whole string using the range because we want to check for those letters inside of two dictionary one for each word, we can use to map these letters based on the dictionary whether they exist or not. we use the get method and a default dict so we do not get a keyerror problem when we are trying to find something in that dictionary as we want to check first if they exist then we add if not we set the default values to be a 0. At the end of it we set to check as the result if the two dictionary are a match with each other which means they are an anagram which just means a word that has the same amount of letters and the same letters but in different orders.

-- TWO SUM -- 

use a dictionary again, we loop through the whole list, we want to check if the target value minus the value of the number on that index already existed in the dictionary or not ? If it does not exist then we add the number on that index into the dictionary. we don't need to think of an edge case as the question specified that there is always going to be a result from the list.

-- GROUP ANAGRAM --

dictionary and the key is an array of the 26 letters and if the letter shows up through that string then you add that index with 1 and keep adding if the letter shows up again. Now we are able to use this keys to store the value which is the string if they have the same key then you put it in as the value inside of the list. result the dictionary.values which are the lists.

-- TOP K ELEMENTH --

use a dictionary but mainly to count only the occurence of the number and after using the dictionary. Create a bucket or basically an array of arrays where each index of the array should represent the amount of times that the number occured, we will be traversing this in reverse later on in order to see each of the values if the value of k is still smaller than the length of the list of results then we are able to add it in, if it is the same then we immediately return it.

-- ENCODE AND DECODE -- 

This is a bit not normal on what we normally need to do, we are suppose to find a way to encode this list of strings, first step is of course go through them one by one, in each iteration we can put the length of the string at the front of the string and then have a delimiter such as "#" or even "$" that depends on you're own preference. Now we are then able to return it for the encode part

for the decode part, we are going to have to go through the string and return them into the list. Now the step to do this is we use an iterator using a while loop. use indexing like i or j up to you but inside of the while loop instead of actually looping through the i, we create another iterator that starts of where i start which, for example j = i, from here we can continue iterating through and we are able to continue to iterate through it and check if it is not a "#" or delimiter of our own choice we add our inner iterator in this case j with 1, if it is we stop there. We then are able to find the length then we start based on what i is and we use string slicing. we get that string from i to j such as: s[i:j] something like this will give us the length and from then on we are able to find the the actual word that we have encoded. by adding the i with whatever j is and plus it with 1 and then for where to stop we use j and set it equal to whatever our new i is and plus it with the length. at the end of it, do not forget to change the i to j so we will continue on to the next word.

-- PRODUCT OF ARRAY EXCEPT SELF -- 

in this one we use the concept of prefix sums, the way we want to do this is we would want to have a prefix and a postfix where those number will represent the numbers that came before them and multiply them on the number and store them inside of the result. its more of a math concept then an actual coding concept. we will use the prefix to count up from the values that came before them. for postfix is the confusing part where you will need to multiply them based on the values that were there already in the result list therefore you will need to iterate them from the back not from the front. You iterate them from the back and you will not be stopping on -1 as again the range is exclusive. 

-- VALID SUDOKU -- 

In this one we use the good ol nested loop to walk through the entire 9x9 grids, we are to check if the value on that specific board position already existed or not in three different places which are whether it already existed inside of the row ?, or did it already existed inside of the col ?, or it already existed inside of the 9 huge squares that is 3x3, the only way we do this is actually we are suppose to divide that row by 3 and also divide that col by 3, by doing that we are able to see which huge col and huge row they actually belong to, lets for example say board position row = 1 and col = 1 if we were to integer divide them by 3 (why 3 ?, because they have the grid size of 3x3) we divide 1//3 for row and 1//3 for col, by doing this we will get the result of row = 0 and col = 0 which is correct that row = 1 and col = 1 will equal to the grid location of row = 0 and col = 0. Then on we check if they exist if they do immediately return False and if they do not exist we add them into their corresponding rows and cols and squares hash set and then we will continue iterating, at the end of the entire loop we will then return True meaning the sudoku is valid.

-- LONGEST CONSECUTIVE -- 

There is some logic to these parts which are to reduce the complexity time for this. We are able to turn the list into a set with a cost of space complexity of an immediate O(n) although we have a benefit for this part we are able to check whether the number is contained inside of the set in a faster time which is O(1) because it is a hash set. Now we would want to check if the number we are currently on have a number before it or not, if it does then it means this is not where we would want to start our counter. If it does not we start the counter and set it to 1 after we do this, we are then able to do a while loop inside to check if the number + with the counter are we able to find that sum value inside of the numSet if we do then it means it is the continuation meaning it is consecutive number after the current number we are at right now and we are then able to continue and increment the counter to the point that we don't find any more values that are the continuation of it. We then have to check which one is bigger which is the current result or the current counter and then we just continue on with the process by that code it will give us the biggest counter we will be able to get from the given list.

-- TWO INT SUM 2 -- 

This is the start of using the two pointer methods we aer told to be using two pointers inside of a single loop not a nested loop because that would just defeat the purpose. we set a left pointer that is on the very left of the list and the right pointer which will be on the very right of the list. With this we are then able to iterate through it with a condition as long as the left is smaller than the right. With this we are then able to find out whether the number at the left index plus the number at the right index will be equal to the target or not, if it is therefore we are able to say that they are the answer, but if the total is too big therefore we know since it is sorted we need to decrement the right side as the right side will be the one that has the big values. if the total is too small therefore we know it is too small then we must increment the left side in order to find the value. again this we are able to solve bc it was told to us that the values will be sorted inside of the list which goes to our favor.